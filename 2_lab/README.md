# Лабораторная работа №2. Параллельные алгоритмы численного интегрирования

Алгоритм был безможно украден у [лектора](https://lira.imamod.ru/mipt202102/L09a_202102_YakobovskiyMV.pdf).
Всем параллельным процессам доступен список отрезков интегрирования, организованный в виде стека. Назовем его глобальным стеком.
* Каждому процессу доступен свой, доступный только этому процессу, локальный стек
* Перед запуском параллельных процессов в глобальный стек помещается единственная запись (в дальнейшем "отрезок"):
– координаты концов отрезка интегрирования,
– значения функции на концах,
– приближенное значение интеграла на этом отрезке.
* Каждый из параллельных процессов выполняет следующий алгоритм:
Пока в глобальном стеке есть отрезки:
- взять один отрезок из глобального стека
- выполнить алгоритм локального стека, но, если в момент обращения к локальному стеку в нем уже есть несколько отрезков, а в глобальном стеке отрезки отсутствуют, то:
 - переместить часть отрезков из локального стека в глобальный стек. 

## Выполнение и запуск
* Код работы находит в файле `main.cc`
* Запуск файла работы с сохранением данных в отдельный файл делается с помощью команды `bash run_lab.sh`
* Когда bash-скрипт отработал, запускаем питоновский файл, который строит нам графики `python3 graphs.py`
* Графики зависимости ускорения от числа процессов для какой-то данной функции (например, sin(1 / (x + 5))) на данном промежутке (например, [-4.999, 0.0]) с данным шагом (например, `1e-3`)

## Результаты
Ниже приведены графики зависимость ускорения от числа процессов для функции sin(1 / (x + 5)) на промежутке [-4.999, 0.0]:
* с шагом 1e-11
<image src="statistic.png">

* с шагом 1e-3
<image src="statistic1.png">

* с шагом 1e-6
<image src="statistic2.png">

Видно, что алгоритм примением в случаях, когда требуется достаточно высокая точность вычислений. Для случаев с малой точностью распараллеливание только замедляет работу программы - по воробьям из пушки. Для высокой точности алгоритм хорошо себя показал. Ускорение на графике значительное.